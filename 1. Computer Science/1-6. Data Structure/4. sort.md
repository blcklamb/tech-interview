## 힙 정렬(Heap Sort) 알고리즘에 대해 설명하고, 이의 시간 복잡도를 설명해 주세요.

> 힙 정렬은 Heap 자료구조를 기반으로 하는 정렬 알고리즘입니다. Heap은 완전 이진 트리로 구성되며 최대 힙 또는 최소 힙의 성질을 가집니다.<br>
> 최대 힙을 사용하는 경우를 기준으로 힙 정렬 알고리즘에 대해 설명하겠습니다. 최대 힙을 생성한 후 루트 노드와 배열의 마지막 노드를 교환합니다. 힙의 크기를 1 감소시킨 다음 루트 노드에 대해 heapify를 재귀 호출하여 전체 트리를 최대 힙으로 만듭니다. 이 과정을 힙의 크기가 1이 될 때까지 반복합니다. 이 과정을 반복하면 정렬된 배열을 만들 수 있습니다.<br>
> 힙 정렬은 항상 O(nlogn)의 시간 복잡도를 가집니다. 힙 생성 단계에서 O(n), 각 heapify 단계에서 O(logn)의 시간이 소요되기 때문입니다. 힙 정렬은 추가적인 메모리 공간이 필요하지 않고 주어진 배열 자체에서 정렬을 수행하므로 공간 복잡도는 O(1)입니다.<br>
> 다만 숫자가 같은 경우에도 교환 및 heapify가 수행될 수 있기 때문에 퀵 정렬과 함께 안정적인 정렬이 아닌 것으로 분류됩니다.

[자료구조 개념 이해하기 '힙과 힙 정렬 알고리즘' - 요즘 IT [곰씨네 IT 블로그]](https://yozm.wishket.com/magazine/detail/2312/)

## 퀵 정렬 알고리즘에 대해 설명하고, 이의 시간 복잡도를 설명해 주세요.

> 퀵 정렬은 분할 정복 알고리즘 중 하나입니다. 리스트 가운데서 하나의 원소를 고르고, 해당 원소를 피벗으로 설정합니다. 피벗 앞에는 피벗보다 작은 모든 원소들이, 뒤에는 피벗보다 큰 모든 원소들이 오도록 리스트를 둘로 나눕니다. 이러한 분할 작업 이후에는 피벗을 고정시켜 놓고, 두 분할된 리스트에 대해 재귀적으로 이 과정을 반복합니다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복합니다.<br>
> 퀵 정렬 알고리즘은 최선의 경우 O(nlogn)이며, 최악의 경우 O(n^2)가 될 수 있습니다.

## 퀵 정렬이 최악의 시간 복잡도를 가지는 경우 해결방안은 무엇인가요?

> 퀵 정렬은 피벗 선택이 최악의 경우, 리스트가 이미 정렬되어 있거나 피벗이 항상 최대 또는 최소값을 선택하는 경우 최악의 시간 복잡도를 가질 수 있습니다.<br>
> 이런 경우 피벗을 무작위로 선택하거나 리스트 내의 중간값을 선택하는 방법을 통해 최악의 경우를 피할 수 있습니다.

## 병합 정렬에 대해 설명해 주세요.

> 병합 정렬은 n개의 요소를 가진 리스트를 n개의 부분 리스트로 분할한 후, 가까운 요소끼리 비교하여 병합하는 과정을 재귀적으로 반복하는 알고리즘입니다. 분할-정복-병합의 반복으로 정렬을 완료합니다.<br>
> 병합 정렬은 최선, 최악 모두 O(nlogn)의 시간 복잡도를 가져 일정한 성능을 보입니다.
